// Generated by CoffeeScript 2.0.0-beta4
var puppeteer, web_page,
  indexOf = [].indexOf;

web_page = require("./web_page.js");

puppeteer = require('puppeteer');

Poltergeist.Browser = class Browser {
  constructor(width, height) {
    this.width = width || 1024;
    this.height = height || 768;
    this.pages = [];
    this.js_errors = true;
    this._debug = false;
    this._counter = 0;
    this.processed_modal_messages = [];
    this.confirm_processes = [];
    this.prompt_responses = [];
  }

  async launch() {
    this.browser = (await puppeteer.launch({
      headless: false
    }));
    return this.resetPage();
  }

  async resetPage() {
    [this._counter, this.pages] = [0, []];
    if (this.page != null) {
      if (!this.page.closed) {
        // @page.clearLocalStorage() if @page.currentUrl() != 'about:blank'
        this.page.close();
      }
    }
    // phantom.clearCookies()
    this.page = this.currentPage = (await this._open_new_window());
    return true;
  }

  getPageByHandle(handle) {
    return this.pages.filter(function(p) {
      return !p.closed && p.handle === handle;
    })[0];
  }

  runCommand(command) {
    this.current_command = command;
    this.currentPage.state = 'default';
    return this[command.name].apply(this, command.args);
  }

  debug(message) {
    if (this._debug) {
      return console.log(`poltergeist [${new Date().getTime()}] ${message}`);
    }
  }

  setModalMessage(msg) {
    this.processed_modal_messages.push(msg);
  }

  add_extension(extension) {
    return this.current_command.sendResponse(this.currentPage.injectExtension(extension).then(function() {
      return 'success';
    }).catch(function(err) {
      throw `Unable to load extension: ${extension}`;
    }));
  }

  node(page_id, id) {
    if (this.currentPage.id === page_id) {
      return this.currentPage.get(id);
    } else {
      throw new Poltergeist.ObsoleteNode;
    }
  }

  async visit(url, max_wait = 30) {
    var command, goto_options, loading_page, prevUrl;
    this.currentPage.state = 'loading';
    //reset modal processing state when changing page
    this.processed_modal_messages = [];
    this.confirm_processes = [];
    this.prompt_responses = [];
    prevUrl = (await this.currentPage.currentUrl());
    goto_options = {
      timeout: max_wait * 1000
    };
    if (/#/.test(url) && prevUrl.split('#')[0] === url.split('#')[0]) {
      // Hash change occurred, so there will be no 'load' event
      goto_options['waitUntil'] = 'networkidle';
      goto_options['networkIdleTimeout'] = 100;
    }
    command = this.current_command;
    loading_page = this.currentPage;
    this.currentPage.goto(url, goto_options).then(function(response) {
      loading_page.state = 'default';
      return command.sendResponse({
        status: (response != null ? response.status : void 0) || 'success'
      });
    }).catch(function(err) {
      var msg, resources;
      resources = loading_page.openResourceRequests();
      msg = resources.length ? `Timed out with the following resources still waiting ${resources.join(',')}` : "Request blocked or timed out with no open resource requests";
      console.log(`returning status fail error ${url} : ${msg}}`);
      return command.sendError(new Poltergeist.StatusFailError(url, msg));
    });
  }

  current_url() {
    return this.current_command.sendResponse(this.currentPage.currentUrl());
  }

  status_code() {
    return this.current_command.sendResponse(this.currentPage.statusCode);
  }

  body() {
    return this.current_command.sendResponse(this.currentPage.content());
  }

  source() {
    return this.current_command.sendResponse(this.currentPage.source);
  }

  title() {
    return this.current_command.sendResponse(this.currentPage.title());
  }

  find(method, selector) {
    this.current_command.sendResponse(this.currentPage.find(method, selector).then((ids) => {
      return {
        page_id: this.currentPage.id,
        ids
      };
    }));
  }

  find_within(page_id, id, method, selector) {
    return this.current_command.sendResponse(this.node(page_id, id).find(method, selector));
  }

  all_text(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).allText());
  }

  visible_text(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).visibleText());
  }

  delete_text(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).deleteText());
  }

  property(page_id, id, name) {
    return this.current_command.sendResponse(this.node(page_id, id).getProperty(name));
  }

  attribute(page_id, id, name) {
    return this.current_command.sendResponse(this.node(page_id, id).getAttribute(name));
  }

  attributes(page_id, id, name) {
    return this.current_command.sendResponse(this.node(page_id, id).getAttributes());
  }

  parents(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).parentIds());
  }

  value(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).value());
  }

  set(page_id, id, value) {
    return this.current_command.sendResponse(this.node(page_id, id).set(value));
  }

  // PhantomJS only allows us to reference the element by CSS selector, not XPath,
  // so we have to add an attribute to the element to identify it, then remove it
  // afterwards.
  select_file(page_id, id, files) {
    var node;
    console.log("selecting file");
    node = this.node(page_id, id);
    return this.current_command.sendResponse(this.currentPage.beforeAction(node.id).then(() => {
      return this.currentPage.uploadFile('[_poltergeist_selected]', ...files).then(() => {
        return this.currentPage.afterAction(node.id);
      });
    }));
  }

  select(page_id, id, value) {
    return this.current_command.sendResponse(this.node(page_id, id).select(value));
  }

  tag_name(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).tagName());
  }

  visible(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).isVisible());
  }

  disabled(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).isDisabled());
  }

  path(page_id, id) {
    return this.current_command.sendResponse(this.node(page_id, id).path());
  }

  evaluate(script, ...args) {
    var arg, i, len;
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (this._isElementArgument(arg)) {
        if (arg["ELEMENT"]["page_id"] !== this.currentPage.id) {
          throw new Poltergeist.ObsoleteNode;
        }
      }
    }
    return this.current_command.sendResponse(this.currentPage.evaluate(`function() { return ${script} }`, ...args));
  }

  execute(script, ...args) {
    var arg, i, len;
    for (i = 0, len = args.length; i < len; i++) {
      arg = args[i];
      if (this._isElementArgument(arg)) {
        if (arg["ELEMENT"]["page_id"] !== this.currentPage.id) {
          throw new Poltergeist.ObsoleteNode;
        }
      }
    }
    return this.current_command.sendResponse(this.currentPage.execute(`function() { ${script} }`, ...args));
  }

  frameUrl(frame_name) {
    return this.currentPage.frameUrl(frame_name);
  }

  async pushFrame(command, node, timeout) {
    var attrs, cur_frame, frame, frame_url, name;
    frame = this.node(...node);
    attrs = (await frame.getAttributes('name', 'id'));
    name = attrs['name'] || attrs['id'];
    if (!name) {
      name = (await frame.setAttribute('name', `_random_name_${new Date().getTime()}`));
    }
    frame_url = (await this.frameUrl(name));
    if (indexOf.call(this.currentPage.blockedUrls(), frame_url) >= 0) {
      console.log("frame blocked");
      command.sendResponse(true);
    } else {
      cur_frame = (await this.currentPage.pushFrame(name));
      if (cur_frame) {
        await cur_frame.waitFor('html');
        command.sendResponse(true);
      } else {
        if (new Date().getTime() < timeout) {
          setTimeout((() => {
            return this.pushFrame(command, node, timeout);
          }), 50);
        } else {
          command.sendError(new Poltergeist.FrameNotFound(name));
        }
      }
    }
    return true;
  }

  push_frame(node, timeout = (new Date().getTime()) + 2000) {
    return this.pushFrame(this.current_command, node, timeout);
  }

  pop_frame(pop_all = false) {
    return this.current_command.sendResponse(this.currentPage.popFrame(pop_all));
  }

  window_handles() {
    var handles;
    handles = this.pages.filter(function(p) {
      return !p.closed;
    }).map(function(p) {
      return p.handle;
    });
    return this.current_command.sendResponse(handles);
  }

  window_handle(name = null) {
    var handle, page;
    handle = name ? (page = this.pages.filter(function(p) {
      return !p.closed && p.windowName() === name;
    })[0], popFramepage ? page.handle : null) : this.currentPage.handle;
    return this.current_command.sendResponse(handle);
  }

  switch_to_window(handle) {
    var command, new_page;
    command = this.current_command;
    new_page = this.getPageByHandle(handle);
    if (new_page) {
      if (new_page !== this.currentPage) {
        return new_page.waitState('default', () => {
          this.currentPage = new_page;
          return command.sendResponse(true);
        });
      } else {
        return command.sendResponse(true);
      }
    } else {
      throw new Poltergeist.NoSuchWindowError;
    }
  }

  async open_new_window() {
    var page;
    // this.execute 'window.open()'
    // @current_command.sendResponse(true)
    page = (await this._open_new_window());
    page.handle = `${this._counter++}`;
    page.setBlacklist(this.page.urlBlacklist);
    page.setWhitelist(this.page.urlWhitelist);
    await page.setViewportSize(this.page.viewportSize());
    return this.current_command.sendResponse(true);
  }

  async _open_new_window() {
    var native_page, page;
    native_page = (await this.browser.newPage());
    page = new Poltergeist.WebPage(native_page);
    await page.initialize();
    page.handle = `${this._counter++}`;
    this.pages.push(page);
    native_page.on('dialog', (dialog) => {
      var process, response;
      this.setModalMessage(dialog.message());
      switch (dialog.type) {
        case 'alert':
          return dialog.dismiss();
        case 'confirm':
        case 'beforeunload':
          process = this.confirm_processes.pop();
          if (process === void 0) {
            process = true;
          }
          if (process) {
            return dialog.accept();
          } else {
            return dialog.dismiss();
          }
          break;
        case 'prompt':
          response = this.prompt_responses.length ? response = this.prompt_responses.pop() : false;
          if (response === false) {
            response = dialog.defaultValue();
          }
          if (response != null) {
            return dialog.accept(response);
          } else {
            return dialog.dismiss();
          }
          break;
        default:
          throw `Unknown dialog type ${dialog.type}`;
      }
    });
    // page.onPageCreated = (newPage) =>
    //   page = new Poltergeist.WebPage(newPage)
    //   page.handle = "#{@_counter++}"
    //   page.setViewportSize(@page.viewportSize())
    //   @pages.push(page)
    this.processed_modal_messages = [];
    this.confirm_processes = [];
    this.prompt_responses = [];
    await page.setViewportSize({
      width: parseInt(this.width, 10),
      height: parseInt(this.height, 10)
    });
    return page;
  }

  close_window(handle) {
    var page;
    page = this.getPageByHandle(handle);
    if (page) {
      page.close();
      return this.current_command.sendResponse(true);
    } else {
      return this.current_command.sendResponse(false);
    }
  }

  mouse_event(page_id, id, name) {
    var node;
    // Get the node before changing state, in case there is an exception
    node = this.node(page_id, id);
    // If the event triggers onNavigationRequested, we will transition to the 'loading'
    // state and wait for onLoadFinished before sending a response.
    this.currentPage.state = 'mouse_event';
    return node.mouseEvent(name).then((last_mouse_event) => {
      var command, event_page;
      event_page = this.currentPage;
      command = this.current_command;
      return new Promise(function(resolve) {
        return setTimeout(function() {
          if (event_page.state === 'mouse_event') {
            event_page.state = 'default';
            command.sendResponse({
              position: last_mouse_event
            });
          } else {
            event_page.waitState('default', function() {
              command.sendResponse({
                position: last_mouse_event
              });
              return resolve();
            });
          }
          return resolve();
        }, 100);
      });
    // setTimeout ->
    //   # If the state is still the same then navigation event won't happen
    //   if event_page.state == 'mouse_event'
    //     console.log "going back to default"
    //     event_page.state = 'default'
    //     console.log "sending:"
    //     console.dir last_mouse_event
    //     command.sendResponse(position: last_mouse_event)
    //   else
    //     console.log "going to wait for default"
    //     event_page.waitState 'default', ->
    //       console.log "page made it to default"
    //       command.sendResponse(position: last_mouse_event)
    //   return true
    // , 1000
    // return true
    }).catch((err) => {
      console.log("in catch");
      return this.current_command.sendError(err);
    });
  }

  click(page_id, id) {
    return this.mouse_event(page_id, id, 'click').catch(function(err) {
      return console.log("error in click");
    });
  }

  right_click(page_id, id) {
    return this.mouse_event(page_id, id, 'rightclick');
  }

  double_click(page_id, id) {
    return this.mouse_event(page_id, id, 'dblclick');
  }

  hover(page_id, id) {
    var node;
    node = this.node(page_id, id);
    // Puppeteer requires locating the element by css to call hover, so we need to adjust element
    return this.current_command.sendResponse(this.currentPage.beforeAction(node.id).then(() => {
      return this.currentPage.native().hover('[_poltergeist_selected]').then(() => {
        return this.currentPage.afterAction(node.id);
      });
    }));
  }

  click_coordinates(x, y) {
    return this.currentPage.native().mouse.click(x, y).then(() => {
      return this.current_command.sendResponse({
        click: {
          x: x,
          y: y
        }
      });
    });
  }

  drag(page_id, id, other_id) {
    return this.current_command.sendResponse(this.node(page_id, id).dragTo(this.node(page_id, other_id)));
  }

  drag_by(page_id, id, x, y) {
    return this.current_command.sendResponse(this.node(page_id, id).dragBy(x, y));
  }

  trigger(page_id, id, event) {
    this.node(page_id, id).trigger(event);
    return this.current_command.sendResponse(event);
  }

  equals(page_id, id, other_id) {
    return this.current_command.sendResponse(this.node(page_id, id).isEqual(this.node(page_id, other_id)));
  }

  reset() {
    return this.current_command.sendResponse(this.resetPage());
  }

  scroll_to(left, top) {
    return this.current_command.sendResponse(this.currentPage.setScrollPosition({
      left: left,
      top: top
    }));
  }

  async send_keys(page_id, id, keys) {
    var cs, target;
    target = this.node(page_id, id);
    // Programmatically generated focus doesn't work for `sendKeys`.
    // That's why we need something more realistic like user behavior.
    cs = (await target.containsSelection());
    if (!cs) {
      await target.mouseEvent('click');
    }
    return this.current_command.sendResponse(this._send_keys_with_modifiers(keys));
  }

  async _send_keys_with_modifiers(keys) {
    var i, j, k, key, len, len1, len2, modifier_key, modifier_keys, sequence;
    for (i = 0, len = keys.length; i < len; i++) {
      sequence = keys[i];
      if (sequence.key != null) {
        key = {
          key: sequence.key
        };
      } else if (sequence.keys != null) {
        key = sequence.keys;
      } else {
        key = sequence;
      }
      if (sequence.modifier != null) {
        modifier_keys = this.currentPage.keyModifierKeys(sequence.modifier);
        for (j = 0, len1 = modifier_keys.length; j < len1; j++) {
          modifier_key = modifier_keys[j];
          await this.currentPage.native().keyboard.down(modifier_key);
        }
        await this._send_keys_with_modifiers([].concat(key));
        for (k = 0, len2 = modifier_keys.length; k < len2; k++) {
          modifier_key = modifier_keys[k];
          await this.currentPage.native().keyboard.up(modifier_key);
        }
      } else if (sequence.key != null) {
        await this.currentPage.native().press(sequence.key);
      } else {
        await this.currentPage.native().type(key);
      }
    }
    return true;
  }

  render_base64(format = 'png', {full = false, selector = null} = {}) {
    var options, p;
    options = {
      fullPage: full,
      type: format
    };
    p = options['fullPage'] ? Promise.resolve(null) : this.get_clip_rect(full, selector);
    return p.then((rect) => {
      if (rect != null) {
        options['clip'] = rect;
      }
      return this.currentPage.native().screenshot(options).then((buffer) => {
        return this.current_command.sendResponse(buffer.toString('base64'));
      });
    });
  }

  render(path, {full = false, selector = null, format = null, quality = null} = {}) {
    var options, p;
    options = {
      path: path,
      fullPage: full
    };
    if (format != null) {
      options['type'] = format;
    }
    if (quality != null) {
      options['quality'] = quality;
    }
    p = options['fullPage'] ? Promise.resolve(null) : this.get_clip_rect(full, selector);
    return p.then((rect) => {
      if (rect != null) {
        options['clip'] = rect;
      }
      return this.currentPage.native().screenshot(options).then(() => {
        return this.current_command.sendResponse(true);
      });
    });
  }

  get_clip_rect(full, selector) {
    return this.currentPage.dimensions().then((dimensions) => {
      var document, viewport;
      [document, viewport] = [dimensions.document, dimensions.viewport];
      if (full) {
        return {
          x: 0,
          y: 0,
          width: document.width,
          height: document.height
        };
      } else {
        if (selector != null) {
          return this.currentPage.elementBounds(selector);
        } else {
          return {
            x: 0,
            y: 0,
            width: viewport.width,
            height: viewport.height
          };
        }
      }
    });
  }

  set_paper_size(size) {
    this.currentPage.setPaperSize(size);
    return this.current_command.sendResponse(true);
  }

  set_zoom_factor(zoom_factor) {
    this.currentPage.setZoomFactor(zoom_factor);
    return this.current_command.sendResponse(true);
  }

  resize(width, height) {
    return this.current_command.sendResponse(this.currentPage.setViewportSize({
      width: parseInt(width, 10),
      height: parseInt(height, 10)
    }).then(function() {
      return true;
    }));
  }

  network_traffic(type) {
    return this.current_command.sendResponse(this.currentPage.networkTraffic(type));
  }

  clear_network_traffic() {
    this.currentPage.clearNetworkTraffic();
    return this.current_command.sendResponse(true);
  }

  set_proxy(ip, port, type, user, password) {
    throw "implement set_proxy";
    phantom.setProxy(ip, port, type, user, password);
    return this.current_command.sendResponse(true);
  }

  get_headers() {
    return this.current_command.sendResponse(this.currentPage.getCustomHeaders());
  }

  async set_headers(headers) {
    await this.currentPage.setCustomHeaders(headers);
    return this.current_command.sendResponse(true);
  }

  async add_headers(headers) {
    var allHeaders, name, value;
    allHeaders = this.currentPage.getCustomHeaders();
    for (name in headers) {
      value = headers[name];
      allHeaders[name] = value;
    }
    return (await this.set_headers(allHeaders));
  }

  async add_header(header, {permanent = true}) {
    if (permanent !== true) {
      this.currentPage.addTempHeader(header);
      if (permanent === "no_redirect") {
        this.currentPage.addTempHeaderToRemoveOnRedirect(header);
      }
    }
    return (await this.add_headers(header));
  }

  response_headers() {
    return this.current_command.sendResponse(this.currentPage.responseHeaders());
  }

  cookies() {
    return this.current_command.sendResponse(this.currentPage.cookies());
  }

  // We're using phantom.addCookie so that cookies can be set
  // before the first page load has taken place.
  set_cookie(cookie) {
    throw "implement set_cookie";
    phantom.addCookie(cookie);
    return this.current_command.sendResponse(true);
  }

  remove_cookie(name) {
    this.currentPage.deleteCookie(name);
    return this.current_command.sendResponse(true);
  }

  clear_cookies() {
    phantom.clearCookies();
    return this.current_command.sendResponse(true);
  }

  cookies_enabled(flag) {
    throw "implement cookies_enabled";
    phantom.cookiesEnabled = flag;
    return this.current_command.sendResponse(true);
  }

  set_http_auth(user, password) {
    this.currentPage.setHttpAuth(user, password);
    return this.current_command.sendResponse(true);
  }

  set_js_errors(value) {
    this.js_errors = value;
    return this.current_command.sendResponse(true);
  }

  set_debug(value) {
    this._debug = value;
    return this.current_command.sendResponse(true);
  }

  async exit() {
    return (await this.browser.close());
  }

  noop() {}

  // NOOOOOOP!

  // This command is purely for testing error handling
  browser_error() {
    throw new Error('zomg');
  }

  async go_back() {
    var response;
    response = (await this.currentPage.goBack({
      waitUntil: 'networkidle',
      networkIdleTimeout: 150
    }));
    return this.current_command.sendResponse(response != null);
  }

  async go_forward() {
    var response;
    response = (await this.currentPage.goForward({
      waitUntil: 'networkidle',
      networkIdleTimeout: 150
    }));
    return this.current_command.sendResponse(response != null);
  }

  async refresh() {
    var response;
    response = (await this.currentPage.reload);
    // waitUntil: 'networkidle'
    // networkIdleTimeout: 150
    return this.current_command.sendResponse(response != null);
  }

  set_url_whitelist(...wildcards) {
    var wc;
    this.currentPage.setWhitelist((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = wildcards.length; i < len; i++) {
        wc = wildcards[i];
        results.push(this._wildcardToRegexp(wc));
      }
      return results;
    }).call(this));
    return this.current_command.sendResponse(true);
  }

  set_url_blacklist(...wildcards) {
    var wc;
    this.currentPage.setBlacklist((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = wildcards.length; i < len; i++) {
        wc = wildcards[i];
        results.push(this._wildcardToRegexp(wc));
      }
      return results;
    }).call(this));
    return this.current_command.sendResponse(true);
  }

  set_confirm_process(process) {
    this.confirm_processes.push(process);
    return this.current_command.sendResponse(true);
  }

  set_prompt_response(response) {
    this.prompt_responses.push(response);
    return this.current_command.sendResponse(true);
  }

  modal_message() {
    return this.current_command.sendResponse(this.processed_modal_messages.shift());
  }

  clear_memory_cache() {
    this.currentPage.clearMemoryCache();
    return this.current_command.sendResponse(true);
  }

  _waitForHistoryChange() {
    var command;
    command = this.current_command;
    return this.currentPage.waitState(['loading', 'default'], function(cur_state) {
      if (cur_state === 'loading') {
        // loading has started, wait for completion
        return this.waitState('default', function() {
          return command.sendResponse(true);
        });
      } else {
        // page has loaded
        return command.sendResponse(true);
      }
    }, 0.5, function() {
      // if haven't moved to loading/default in time assume history API state change
      this.state = 'default';
      return command.sendResponse(true);
    });
  }

  _wildcardToRegexp(wildcard) {
    wildcard = wildcard.replace(/[\-\[\]\/\{\}\(\)\+\.\\\^\$\|]/g, "\\$&");
    wildcard = wildcard.replace(/\*/g, ".*");
    wildcard = wildcard.replace(/\?/g, ".");
    return new RegExp(wildcard, "i");
  }

  _isElementArgument(arg) {
    return typeof arg === "object" && typeof arg['ELEMENT'] === "object";
  }

};
