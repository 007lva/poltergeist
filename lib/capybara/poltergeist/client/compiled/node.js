// Generated by CoffeeScript 2.0.0-beta4
// Proxy object for forwarding method calls to the node object inside the page.
Poltergeist.Node = (function() {
  var fn, j, len, name, ref;

  class Node {
    constructor(page, id) {
      this.page = page;
      this.id = id;
    }

    parent() {
      return new Poltergeist.Node(this.page, this.parentId());
    }

    async mouseEventPosition() {
      var area_offset, image, middle, p, pos, viewport;
      viewport = this.page.viewportSize();
      image = (await this._getAreaImage());
      pos = image ? (p = (await image.position()), area_offset = (await this._getAreaOffsetRect()), area_offset ? (p.left = p.left + area_offset.x, p.right = p.left + area_offset.width, p.top = p.top + area_offset.y, p.bottom = p.top + area_offset.height) : void 0, p) : (await this.position());
      middle = function(start, end, size) {
        return Math.round(start + ((Math.min(end, size) - start) / 2));
      };
      return {
        x: middle(pos.left, pos.right, viewport.width),
        y: middle(pos.top, pos.bottom, viewport.height)
      };
    }

    async mouseEvent(name) {
      var area_image, pos, test;
      area_image = (await this._getAreaImage());
      if (area_image) {
        await area_image.scrollIntoView();
      } else {
        await this.scrollIntoView();
      }
      pos = (await this.mouseEventPosition());
      test = (await this.mouseEventTest(pos.x, pos.y));
      if (test.status === 'success') {
        if (name === 'rightclick') {
          this.page.mouseEvent('click', pos.x, pos.y, 'right');
          this.trigger('contextmenu');
        } else {
          this.page.mouseEvent(name, pos.x, pos.y);
        }
        return pos;
      } else {
        return Promise.reject(new Poltergeist.MouseEventFailed(name, test.selector, pos));
      }
    }

    async dragTo(other) {
      await this.scrollIntoView();
      return Promise.all([this.mouseEventPosition(), other.mouseEventPosition()]).then((positions) => {
        return this.page.mouseEvent('mousedown', positions[0].x, positions[0].y).then(() => {
          return new Promise(function(resolve) {
            return setTimeout(resolve, 100);
          }).then(() => {
            return this.page.mouseEvent('mouseup', positions[1].x, positions[1].y).then;
          });
        });
      });
    }

    async dragBy(x, y) {
      var final_pos, position;
      await this.scrollIntoView();
      position = (await this.mouseEventPosition());
      final_pos = {
        x: position.x + x,
        y: position.y + y
      };
      return this.page.mouseEvent('mousedown', position.x, position.y).then(() => {
        return this.page.mouseEvent('mouseup', final_pos.x, final_pos.y);
      });
    }

    isEqual(other) {
      return this.page === other.page && this.isDOMEqual(other.id);
    }

    async _getAreaOffsetRect() {
      var attrs, centerX, centerY, coord, coords, i, maxX, maxY, minX, minY, radius, rect, shape, x, xs, y, ys;
      // get the offset of the center of selected area
      attrs = (await this.getAttributes('shape', 'coords'));
      shape = attrs['shape'].toLowerCase();
      coords = (function() {
        var k, len1, ref1, results;
        ref1 = attrs['coords'].split(',');
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          coord = ref1[k];
          results.push(parseInt(coord, 10));
        }
        return results;
      })();
      return rect = (function() {
        switch (shape) {
          case 'rect':
          case 'rectangle':
            //coords.length == 4
            [x, y] = coords;
            return {
              x: x,
              y: y,
              width: coords[2] - x,
              height: coords[3] - y
            };
          case 'circ':
          case 'circle':
            // coords.length == 3
            [centerX, centerY, radius] = coords;
            return {
              x: centerX - radius,
              y: centerY - radius,
              width: 2 * radius,
              height: 2 * radius
            };
          case 'poly':
          case 'polygon':
            // coords.length > 2
            // This isn't correct for highly concave polygons but is probably good enough for
            // use in a testing tool
            xs = (function() {
              var k, ref1, results;
              results = [];
              for (i = k = 0, ref1 = coords.length; k < ref1; i = k += 2) {
                results.push(coords[i]);
              }
              return results;
            })();
            ys = (function() {
              var k, ref1, results;
              results = [];
              for (i = k = 1, ref1 = coords.length; k < ref1; i = k += 2) {
                results.push(coords[i]);
              }
              return results;
            })();
            minX = Math.min(...xs);
            maxX = Math.max(...xs);
            minY = Math.min(...ys);
            maxY = Math.max(...ys);
            return {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY
            };
        }
      })();
    }

    _getAreaImage() {
      return this.tagName().then((tn) => {
        var map;
        if (tn.toLowerCase() === 'area') {
          map = this.parent();
          return this.parent().then((map) => {
            return map.tagName().then((map_tn) => {
              if (map_tn.toLowerCase() !== 'map') {
                throw new Error('the area is not within a map');
              }
              return map.getAttribute('name').then((mapName) => {
                var image_node_id;
                if (mapName == null) {
                  throw new Error("area's parent map must have a name");
                }
                mapName = '#' + mapName.toLowerCase();
                return image_node_id = this.page.find('css', `img[usemap='${mapName}']`).then((els) => {
                  image_node_id = els[0];
                  if (image_node_id == null) {
                    throw new Error("no image matches the map");
                  }
                  return this.page.get(image_node_id);
                });
              });
            });
          });
        }
      });
    }

  };

  Node.DELEGATES = ['allText', 'visibleText', 'getAttribute', 'getAttributes', 'value', 'set', 'setAttribute', 'isObsolete', 'removeAttribute', 'isMultiple', 'select', 'tagName', 'find', 'isVisible', 'isInViewport', 'position', 'trigger', 'parentId', 'parentIds', 'mouseEventTest', 'scrollIntoView', 'isDOMEqual', 'isDisabled', 'deleteText', 'containsSelection', 'path', 'getProperty'];

  ref = Node.DELEGATES;
  fn = (name) => {
    return Node.prototype[name] = function(...args) {
      return this.page.nodeCall(this.id, name, args);
    };
  };
  for (j = 0, len = ref.length; j < len; j++) {
    name = ref[j];
    fn(name);
  }

  return Node;

})();
