// Generated by CoffeeScript 2.0.0-beta4
  // This is injected into each page that is loaded
var PoltergeistAgent,
  indexOf = [].indexOf,
  hasProp = {}.hasOwnProperty;

PoltergeistAgent = class PoltergeistAgent {
  constructor() {
    this.elements = [];
    this.nodes = {};
  }

  externalCall(name, args) {
    var error;
    try {
      return {
        value: this[name].apply(this, args)
      };
    } catch (error1) {
      error = error1;
      return {
        error: {
          message: error.toString(),
          stack: error.stack
        }
      };
    }
  }

  find(method, selector, within = document) {
    var el, error, i, j, len, results, results1, xpath;
    try {
      if (method === "xpath") {
        xpath = document.evaluate(selector, within, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        results = (function() {
          var j, ref, results1;
          results1 = [];
          for (i = j = 0, ref = xpath.snapshotLength; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results1.push(xpath.snapshotItem(i));
          }
          return results1;
        })();
      } else {
        results = within.querySelectorAll(selector);
      }
      results1 = [];
      for (j = 0, len = results.length; j < len; j++) {
        el = results[j];
        results1.push(this.register(el));
      }
      return results1;
    } catch (error1) {
      error = error1;
      // DOMException.INVALID_EXPRESSION_ERR is undefined, using pure code
      if (error.code === DOMException.SYNTAX_ERR || error.code === 51) {
        throw new PoltergeistAgent.InvalidSelector;
      } else {
        throw error;
      }
    }
  }

  register(element) {
    this.elements.push(element);
    return this.elements.length - 1;
  }

  documentSize() {
    return {
      height: document.documentElement.scrollHeight || document.documentElement.clientHeight,
      width: document.documentElement.scrollWidth || document.documentElement.clientWidth
    };
  }

  get(id) {
    var base;
    return (base = this.nodes)[id] || (base[id] = new PoltergeistAgent.Node(this, this.elements[id]));
  }

  nodeCall(id, name, args) {
    var node;
    node = this.get(id);
    if (node.isObsolete()) {
      throw new PoltergeistAgent.ObsoleteNode;
    }
    return node[name].apply(node, args);
  }

  beforeAction(id, name) {
    this.get(id).setAttribute('_poltergeist_selected', '');
    return true;
  }

  afterAction(id) {
    this.get(id).removeAttribute('_poltergeist_selected');
    return true;
  }

  clearLocalStorage() {
    return typeof localStorage !== "undefined" && localStorage !== null ? localStorage.clear() : void 0;
  }

  wrapResults(result, page_id) {
    var j, key, len, obj, res, results1, val;
    this._visitedObjects || (this._visitedObjects = []);
    switch (false) {
      case indexOf.call(this._visitedObjects, result) < 0:
        return '(cyclic structure)';
      case !(Array.isArray(result) || (result instanceof NodeList)):
        results1 = [];
        for (j = 0, len = result.length; j < len; j++) {
          res = result[j];
          results1.push(this.wrapResults(res, page_id));
        }
        return results1;
        break;
      case !(result && result.nodeType === 1 && result['tagName']):
        return {
          'ELEMENT': {
            id: this.register(result),
            page_id: page_id
          }
        };
      case !(result == null):
        return void 0;
      case typeof result !== 'object':
        this._visitedObjects.push(result);
        obj = {};
        for (key in result) {
          if (!hasProp.call(result, key)) continue;
          val = result[key];
          obj[key] = this.wrapResults(val, page_id);
        }
        this._visitedObjects.pop();
        return obj;
      default:
        return result;
    }
  }

};

PoltergeistAgent.ObsoleteNode = class ObsoleteNode {
  toString() {
    return "PoltergeistAgent.ObsoleteNode";
  }

};

PoltergeistAgent.InvalidSelector = class InvalidSelector {
  toString() {
    return "PoltergeistAgent.InvalidSelector";
  }

};

PoltergeistAgent.Node = (function() {
  class Node {
    constructor(agent, element1) {
      this.agent = agent;
      this.element = element1;
    }

    parentId() {
      return this.agent.register(this.element.parentNode);
    }

    parentIds() {
      var ids, parent;
      ids = [];
      parent = this.element.parentNode;
      while (parent !== document) {
        ids.push(this.agent.register(parent));
        parent = parent.parentNode;
      }
      return ids;
    }

    find(method, selector) {
      return this.agent.find(method, selector, this.element);
    }

    isObsolete() {
      var obsolete;
      obsolete = (element) => {
        var parent;
        if ((parent = element != null ? element.parentNode : void 0) != null) {
          if (parent === document) {
            return false;
          } else {
            return obsolete(parent);
          }
        } else {
          return true;
        }
      };
      return obsolete(this.element);
    }

    changed() {
      var element, event;
      event = new Event('change', {
        bubbles: true,
        cancelable: false
      });
      // In the case of an OPTION tag, the change event should come
      // from the parent SELECT
      element = this.element.nodeName === 'OPTION' ? (element = this.element.parentNode, element.nodeName === 'OPTGROUP' ? element = element.parentNode : void 0, element) : this.element;
      return element.dispatchEvent(event);
    }

    input() {
      var event;
      event = new InputEvent('input');
      return this.element.dispatchEvent(event);
    }

    keyupdowned(eventName, keyCode) {
      var event;
      event = new KeyboardEvent(eventName, {
        keyCode: keyCode
      });
      return this.element.dispatchEvent(event);
    }

    keypressed(altKey, ctrlKey, shiftKey, metaKey, keyCode, charCode) {
      var event;
      event = new KeyboardEvent('keypress', {
        window: this.agent.window,
        altKey,
        ctrlKey,
        shiftKey,
        metaKey,
        keyCode,
        charCode
      });
      return this.element.dispatchEvent(event);
    }

    insideBody() {
      return this.element === document.body || document.evaluate('ancestor::body', this.element, null, XPathResult.BOOLEAN_TYPE, null).booleanValue;
    }

    allText() {
      return this.element.textContent;
    }

    visibleText() {
      if (this.isVisible()) {
        if (this.element.nodeName === "TEXTAREA") {
          return this.element.textContent;
        } else {
          if (this.element instanceof SVGElement) {
            return this.element.textContent;
          } else {
            return this.element.innerText;
          }
        }
      }
    }

    deleteText() {
      var range;
      range = document.createRange();
      range.selectNodeContents(this.element);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
      window.getSelection().deleteFromDocument();
      return window.getSelection().removeAllRanges();
    }

    getProperty(name) {
      return this.element[name];
    }

    getAttributes() {
      var attr, attrs, j, len, ref;
      attrs = {};
      ref = this.element.attributes;
      for (j = 0, len = ref.length; j < len; j++) {
        attr = ref[j];
        attrs[attr.name] = attr.value.replace("\n", "\\n");
      }
      return attrs;
    }

    getAttribute(name) {
      var ref;
      if (name === 'checked' || name === 'selected') {
        return this.element[name];
      } else {
        return (ref = this.element.getAttribute(name)) != null ? ref : void 0;
      }
    }

    scrollIntoView() {
      return this.element.scrollIntoViewIfNeeded();
    }

    value() {
      var j, len, option, ref, results1;
      if (this.element.tagName === 'SELECT' && this.element.multiple) {
        ref = this.element.children;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          option = ref[j];
          if (option.selected) {
            results1.push(option.value);
          }
        }
        return results1;
      } else {
        return this.element.value;
      }
    }

    set(value) {
      var char, j, keyCode, len;
      if (this.element.readOnly) {
        return;
      }
      if (this.element.maxLength >= 0) {
        value = value.substr(0, this.element.maxLength);
      }
      this.trigger('focus');
      this.element.value = '';
      if (this.element.type === 'number') {
        this.element.value = value;
      } else {
        for (j = 0, len = value.length; j < len; j++) {
          char = value[j];
          keyCode = this.characterToKeyCode(char);
          this.keyupdowned('keydown', keyCode);
          this.element.value += char;
          this.keypressed(false, false, false, false, char.charCodeAt(0), char.charCodeAt(0));
          this.keyupdowned('keyup', keyCode);
        }
      }
      this.changed();
      this.input();
      return this.trigger('blur');
    }

    isMultiple() {
      return this.element.multiple;
    }

    setAttribute(name, value) {
      this.element.setAttribute(name, value);
      return value;
    }

    removeAttribute(name) {
      return this.element.removeAttribute(name);
    }

    select(value) {
      if (this.isDisabled()) {
        return false;
      } else if (value === false && !this.element.parentNode.multiple) {
        return false;
      } else {
        this.trigger('focus', this.element.parentNode);
        this.element.selected = value;
        this.changed();
        this.trigger('blur', this.element.parentNode);
        return true;
      }
    }

    tagName() {
      return this.element.tagName;
    }

    isVisible(element = this.element) {
      var map_name, style;
      //if an area element, check visibility of relevant image
      if (element.tagName === 'AREA') {
        map_name = document.evaluate('./ancestor::map/@name', element, null, XPathResult.STRING_TYPE, null).stringValue;
        element = document.querySelector(`img[usemap='#${map_name}']`);
        if (element == null) {
          return false;
        }
      }
      while (element) {
        style = window.getComputedStyle(element);
        if (style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) === 0) {
          return false;
        }
        element = element.parentElement;
      }
      return true;
    }

    isInViewport() {
      var rect;
      rect = this.element.getBoundingClientRect();
      return rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
    }

    isDisabled() {
      var xpath;
      xpath = 'parent::optgroup[@disabled] | ancestor::select[@disabled] | parent::fieldset[@disabled] | ancestor::*[not(self::legend) or preceding-sibling::legend][parent::fieldset[@disabled]]';
      return this.element.disabled || document.evaluate(xpath, this.element, null, XPathResult.BOOLEAN_TYPE, null).booleanValue;
    }

    path() {
      var elements, selectors;
      elements = this.parentIds().reverse().map((id) => {
        return this.agent.get(id);
      });
      elements.push(this);
      selectors = elements.map(function(el) {
        var prev_siblings;
        prev_siblings = el.find('xpath', `./preceding-sibling::${el.tagName()}`);
        return `${el.tagName()}[${prev_siblings.length + 1}]`;
      });
      return "//" + selectors.join('/');
    }

    containsSelection() {
      var selectedNode;
      selectedNode = document.getSelection().focusNode;
      if (!selectedNode) {
        return false;
      }
      if (selectedNode.nodeType === 3) {
        console.log("getting parentNode");
        selectedNode = selectedNode.parentNode;
      }
      return this.element.contains(selectedNode);
    }

    frameOffset() {
      var offset, rect, style, win;
      win = window;
      offset = {
        top: 0,
        left: 0
      };
      while (win.frameElement) {
        rect = win.frameElement.getClientRects()[0];
        style = win.getComputedStyle(win.frameElement);
        win = win.parent;
        offset.top += rect.top + parseInt(style.getPropertyValue("padding-top"), 10);
        offset.left += rect.left + parseInt(style.getPropertyValue("padding-left"), 10);
      }
      return offset;
    }

    position() {
      var frameOffset, pos, rect;
      // Elements inside an SVG return underfined for getClientRects???
      rect = this.element.getClientRects()[0] || this.element.getBoundingClientRect();
      if (!rect) {
        throw new PoltergeistAgent.ObsoleteNode;
      }
      frameOffset = this.frameOffset();
      pos = {
        top: rect.top + frameOffset.top,
        right: rect.right + frameOffset.left,
        left: rect.left + frameOffset.left,
        bottom: rect.bottom + frameOffset.top,
        width: rect.width,
        height: rect.height
      };
      return pos;
    }

    trigger(name, element = this.element) {
      var event;
      if (indexOf.call(Node.EVENTS.MOUSE, name) >= 0) {
        event = new MouseEvent(name, {
          bubbles: true,
          cancelable: true,
          view: window
        });
      } else if (indexOf.call(Node.EVENTS.FOCUS, name) >= 0) {
        event = new FocusEvent(name, {
          bubbles: true,
          cancelable: true
        });
      } else if (indexOf.call(Node.EVENTS.FORM, name) >= 0) {
        event = new Event(name, {
          bubbles: true,
          cancelable: true
        });
      } else {
        throw "Unknown event";
      }
      return element.dispatchEvent(event);
    }

    mouseEventTest(x, y) {
      var el, frameOffset, origEl;
      frameOffset = this.frameOffset();
      x -= frameOffset.left;
      y -= frameOffset.top;
      el = origEl = document.elementFromPoint(x, y);
      while (el) {
        if (el === this.element) {
          return {
            status: 'success'
          };
        } else {
          el = el.parentNode;
        }
      }
      return {
        status: 'failure',
        selector: origEl && this.getSelector(origEl)
      };
    }

    getSelector(el) {
      var className, classes, j, len, ref, ref1, selector;
      selector = el.tagName !== 'HTML' ? this.getSelector(el.parentNode) + ' ' : '';
      selector += el.tagName.toLowerCase();
      if (el.id) {
        selector += `#${el.id}`;
      }
      //PhantomJS < 2.0 doesn't support classList for SVG elements - so get classes manually
      classes = el.classList || ((ref = el.getAttribute('class')) != null ? (ref1 = ref.trim()) != null ? ref1.split(/\s+/) : void 0 : void 0) || [];
      for (j = 0, len = classes.length; j < len; j++) {
        className = classes[j];
        if (className !== '') {
          selector += `.${className}`;
        }
      }
      return selector;
    }

    characterToKeyCode(character) {
      var code, specialKeys;
      code = character.toUpperCase().charCodeAt(0);
      specialKeys = {
        96: 192, //`
        45: 189, //-
        61: 187, //=
        91: 219, //[
        93: 221, //]
        92: 220, //\
        59: 186, //;
        39: 222, //'
        44: 188, //,
        46: 190, //.
        47: 191, ///
        127: 46, //delete
        126: 192, //~
        33: 49, //!
        64: 50, //@
        35: 51, //#
        36: 52, //$
        37: 53, //%
        94: 54, //^
        38: 55, //&
        42: 56, //*
        40: 57, //(
        41: 48, //)
        95: 189, //_
        43: 187, //+
        123: 219, //{
        125: 221, //}
        124: 220, //|
        58: 186, //:
        34: 222, //"
        60: 188, //<
        62: 190, //>
        63: 191 //?
      };
      return specialKeys[code] || code;
    }

    isDOMEqual(other_id) {
      return this.element === this.agent.get(other_id).element;
    }

  };

  Node.EVENTS = {
    FOCUS: ['blur', 'focus', 'focusin', 'focusout'],
    MOUSE: ['click', 'dblclick', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseover', 'mouseout', 'mouseup', 'contextmenu'],
    FORM: ['submit']
  };

  return Node;

})();

window.__poltergeist = new PoltergeistAgent;

document.addEventListener('DOMContentLoaded', function() {
  return console.log('__DOMContentLoaded');
});
