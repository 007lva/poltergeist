// Generated by CoffeeScript 2.0.0-beta4
var fs, node, tab_id,
  indexOf = [].indexOf,
  hasProp = {}.hasOwnProperty;

node = require("./node.js");

fs = require('fs');

tab_id = 0;

Poltergeist.WebPage = (function() {
  var command, delegate, fn1, fn2, i, j, len, len1, ref, ref1;

  class WebPage {
    constructor(_native) {
      var callback, k, len2, ref2;
      this._native = _native;
      this.id = ++tab_id;
      this.source = null;
      this.closed = false;
      this.state = 'default';
      this.frames = [];
      this.urlWhitelist = [];
      this.urlBlacklist = [];
      this.errors = [];
      this._networkTraffic = {};
      this._customHeaders = {};
      this._tempHeaders = {};
      this._blockedUrls = [];
      this._requestedResources = {};
      this._responseHeaders = [];
      this._tempHeadersToRemoveOnRedirect = {};
      ref2 = WebPage.CALLBACKS;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        callback = ref2[k];
        this.bindCallback(callback);
      }
    }

    initialize() {
      var filePath;
      return Promise.all((function() {
        var k, len2, ref2, results1;
        ref2 = ["./lib/capybara/poltergeist/client/compiled/agent.js", ...WebPage.EXTENSIONS];
        results1 = [];
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          filePath = ref2[k];
          results1.push(this._add_injection(filePath).then((contents) => {
            return this.currentFrame().evaluate(contents);
          }));
        }
        return results1;
      }).call(this)).then(() => {
        return true;
      });
    }

    // onInitializedNative: ->
    //   @id += 1
    //   @source = null
    //   @removeTempHeaders()
    //   @removeTempHeadersForRedirect()
    //   @setScrollPosition(left: 0, top: 0)
    onClosingNative() {
      this.handle = null;
      return this.closed = true;
    }

    on_console(message, ...args) {
      if (message === '__DOMContentLoaded') {

      } else {
        // @source = @_native.content
        // false
        return console.log(message);
      }
    }

    on_pageerror(message) {
      // Puppeteer doesn't seem to provide the stack
      //   stackString = message

      //   stack.forEach (frame) ->
      //     stackString += "\n"
      //     stackString += "    at #{frame.file}:#{frame.line}"
      //     stackString += " in #{frame.function}" if frame.function && frame.function != ''

      this.errors.push({
        message: message.toString(),
        stack: message.toString()
      });
      return true;
    }

    on_error(error) {
      this.errors.push({
        message: error.message.toString(),
        stack: error.stack.toString()
      });
      return true;
    }

    on_framenavigated(frame) {
      if (frame._id === this.currentFrame()._id) {
        this.state = 'loading';
        this.requestId = this.lastRequestId;
        this._requestedResources = {};
      }
      return true;
    }

    on_load() {
      this.state = 'default';
      return this.id = ++tab_id;
    }

    // @source or= @_native.content

    // onLoadFinishedNative: (@status) ->
    //   @state = 'default'
    //   @source or= @_native.content
    on_request(request) {
      var ref2;
      this._networkTraffic[request._requestId] = {
        request: request,
        responseParts: [],
        error: null
      };
      // Intecepting causes the `Referer` header to be lost, therefore
      // we only intercept when black/whitelist are set so we can
      // maintain the headers for now
      if (this._intercepting) {
        if (this._blockRequest(request.url)) {
          this._networkTraffic[request._requestId].blocked = true;
          if (ref2 = request.url, indexOf.call(this._blockedUrls, ref2) < 0) {
            this._blockedUrls.push(request.url);
          }
          request.abort();
        } else {
          this.lastRequestId = request._requestId;
          // @normalizeURL(request.url).then (url)=>
          //   if (url == @redirectURL)
          //     @removeTempHeadersForRedirect()
          //     @redirectURL = null
          //     @requestId   = request._requestId
          this._requestedResources[request._requestId] = request.url;
          request.continue();
        }
      } else {
        this.lastRequestId = request._requestId;
        this._requestedResources[request._requestId] = request.url;
      }
      return true;
    }

    on_response(response) {
      var ref2;
      if ((ref2 = this._networkTraffic[response.request._requestId]) != null) {
        ref2.responseParts.push(response);
      }
      return true;
    }

    on_requestfinished(request) {
      var ref2;
      if ((ref2 = this._networkTraffic[request._requestId]) != null) {
        ref2.responseParts.push(request.response());
      }
      delete this._requestedResources[request.requestId];
      if (this.requestId === request._requestId) {
        if (request.response().redirectURL) {
          return this.removeTempHeadersForRedirect();
        } else {
          // @normalizeURL(response.redirectURL).then (url)=>
          //   @redirectURL = url
          this.statusCode = request.response().status;
          return this._responseHeaders = request.response().headers;
        }
      }
    }

    on_requestfailed(request) {
      var ref2;
      if ((ref2 = this._networkTraffic[request._requestId]) != null) {
        ref2.error = request;
      }
      delete this._requestedResources[request._requestId];
      return true;
    }

    injectExtension(filePath) {
      WebPage.EXTENSIONS.push(filePath);
      return this._add_injection(filePath);
    }

    native() {
      if (this.closed) {
        throw new Poltergeist.NoSuchWindowError;
      } else {
        return this._native;
      }
    }

    currentUrl() {
      // Puppeteer url doesn't reflect
      // @native().url()
      return this.currentFrame().evaluate(function() {
        return window.location.href;
      });
    }

    currentFrame() {
      return this.frames[this.frames.length - 1] || this.native().mainFrame();
    }

    uploadFile(selector, ...file_paths) {
      return this.currentFrame().$(selector).then(function(eh) {
        return eh.uploadFile(...file_paths);
      });
    }

    windowName() {
      return this.native().windowName;
    }

    keyModifierKeys(names) {
      var k, len2, name, ref2, results1;
      ref2 = names.split(',');
      results1 = [];
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        name = ref2[k];
        if (!(name !== 'keypad')) {
          continue;
        }
        name = name.charAt(0).toUpperCase() + name.substring(1);
        if (name === "Ctrl") {
          results1.push("Control");
        } else {
          results1.push(name);
        }
      }
      return results1;
    }

    _waitState_until(states, callback, timeout, timeout_callback) {
      var ref2;
      if ((ref2 = this.state, indexOf.call(states, ref2) >= 0)) {
        return callback.call(this, this.state);
      } else {
        if (new Date().getTime() > timeout) {
          return timeout_callback.call(this);
        } else {
          return setTimeout((() => {
            return this._waitState_until(states, callback, timeout, timeout_callback);
          }), 100);
        }
      }
    }

    waitState(states, callback, max_wait = 0, timeout_callback) {
      var ref2, timeout;
      // callback and timeout_callback will be called with this == the current page
      states = [].concat(states);
      if (ref2 = this.state, indexOf.call(states, ref2) >= 0) {
        return callback.call(this, this.state);
      } else {
        if (max_wait !== 0) {
          timeout = new Date().getTime() + (max_wait * 1000);
          return setTimeout((() => {
            return this._waitState_until(states, callback, timeout, timeout_callback);
          }), 100);
        } else {
          return setTimeout((() => {
            return this.waitState(states, callback);
          }), 100);
        }
      }
    }

    setHttpAuth(user, password) {
      this.native().settings.userName = user;
      this.native().settings.password = password;
      return true;
    }

    networkTraffic(type) {
      var id, k, len2, request, requests, results1;
      console.log("traffic is");
      console.dir(this._networkTraffic);
      requests = (function() {
        var ref2, ref3, ref4, results1, results2, results3;
        switch (type) {
          case 'all':
            ref2 = this._networkTraffic;
            results1 = [];
            for (id in ref2) {
              if (!hasProp.call(ref2, id)) continue;
              request = ref2[id];
              results1.push(request);
            }
            return results1;
            break;
          case 'blocked':
            ref3 = this._networkTraffic;
            results2 = [];
            for (id in ref3) {
              if (!hasProp.call(ref3, id)) continue;
              request = ref3[id];
              if (request.blocked) {
                results2.push(request);
              }
            }
            return results2;
            break;
          default:
            ref4 = this._networkTraffic;
            results3 = [];
            for (id in ref4) {
              if (!hasProp.call(ref4, id)) continue;
              request = ref4[id];
              if (!request.blocked) {
                results3.push(request);
              }
            }
            return results3;
        }
      }).call(this);
      results1 = [];
      for (k = 0, len2 = requests.length; k < len2; k++) {
        request = requests[k];
        results1.push(JSON.stringify(request, ['_requestId', 'url', 'method', 'postData', 'headers', 'blocked']));
      }
      return results1;
    }

    clearNetworkTraffic() {
      this._networkTraffic = {};
      return true;
    }

    blockedUrls() {
      return this._blockedUrls;
    }

    clearBlockedUrls() {
      this._blockedUrls = [];
      return true;
    }

    openResourceRequests() {
      var id, ref2, results1, url;
      ref2 = this._requestedResources;
      results1 = [];
      for (id in ref2) {
        if (!hasProp.call(ref2, id)) continue;
        url = ref2[id];
        results1.push(url);
      }
      return results1;
    }

    content() {
      return this.native().content();
    }

    title() {
      return this.native().title();
    }

    frameUrl(frameNameOrId) {
      var query;
      query = function(frameNameOrId) {
        var ref2;
        return (ref2 = document.querySelector(`iframe[name='${frameNameOrId}'], iframe[id='${frameNameOrId}']`)) != null ? ref2.src : void 0;
      };
      return this.evaluate(query, frameNameOrId);
    }

    clearErrors() {
      this.errors = [];
      return true;
    }

    responseHeaders() {
      var headers;
      headers = {};
      this._responseHeaders.forEach(function(value, key) {
        return headers[key] = value;
      });
      return headers;
    }

    cookies() {
      return this.currentFrame().cookies;
    }

    deleteCookie(name) {
      return this.currentFrame().deleteCookie(name);
    }

    viewportSize() {
      return this.native().viewport();
    }

    setViewportSize(size) {
      return this.native().setViewport(size);
    }

    setZoomFactor(zoom_factor) {
      return this.native().zoomFactor = zoom_factor;
    }

    setPaperSize(size) {
      return this.native().paperSize = size;
    }

    scrollPosition() {
      throw "not implemented";
      return this.native().scrollPosition;
    }

    setScrollPosition(pos) {
      return this.currentFrame().evaluate(function(x, y) {
        return window.scrollTo(x, y);
      }, pos.left, pos.top);
    }

    // clipRect: ->
    //   this.native().clipRect

    // setClipRect: (rect) ->
    //   this.native().clipRect = rect
    elementBounds(selector) {
      return this.currentFrame().evaluate(function(selector) {
        var rect;
        rect = document.querySelector(selector).getBoundingClientRect();
        return {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          top: rect.top,
          bottom: rect.bottom,
          left: rect.left,
          right: rect.right
        };
      }, selector);
    }

    setUserAgent(userAgent) {
      return this.native().setUserAgent(userAgent);
    }

    getCustomHeaders() {
      return this._customHeaders;
    }

    setCustomHeaders(headers) {
      this._customHeaders = headers;
      return (this._customHeaders['User-Agent'] ? this.setUserAgent(this._customHeaders['User-Agent']) : Promise.resolve()).then(() => {
        var map, name, value;
        map = new Map();
        for (name in headers) {
          value = headers[name];
          map.set(name, value);
        }
        return this.native().setExtraHTTPHeaders(map);
      });
    }

    addTempHeader(header) {
      var name, value;
      for (name in header) {
        value = header[name];
        this._tempHeaders[name] = value;
      }
      return this._tempHeaders;
    }

    addTempHeaderToRemoveOnRedirect(header) {
      var name, value;
      for (name in header) {
        value = header[name];
        this._tempHeadersToRemoveOnRedirect[name] = value;
      }
      return this._tempHeadersToRemoveOnRedirect;
    }

    removeTempHeadersForRedirect() {
      var allHeaders, name, ref2, value;
      allHeaders = this.getCustomHeaders();
      ref2 = this._tempHeadersToRemoveOnRedirect;
      for (name in ref2) {
        value = ref2[name];
        delete allHeaders[name];
      }
      return this.setCustomHeaders(allHeaders);
    }

    removeTempHeaders() {
      var allHeaders, name, ref2, value;
      allHeaders = this.getCustomHeaders();
      ref2 = this._tempHeaders;
      for (name in ref2) {
        value = ref2[name];
        delete allHeaders[name];
      }
      return this.setCustomHeaders(allHeaders);
    }

    pushFrame(name) {
      var frame, new_frame, promises;
      new_frame = ((function() {
        var k, len2, ref2, results1;
        ref2 = this.currentFrame().childFrames();
        results1 = [];
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          frame = ref2[k];
          if (frame.name() === name) {
            results1.push(frame);
          }
        }
        return results1;
      }).call(this))[0];
      if (new_frame) {
        this.frames.push(new_frame);
        return Promise.resolve(new_frame);
      } else {
        promises = (function() {
          var k, len2, ref2, results1;
          ref2 = this.currentFrame().childFrames();
          results1 = [];
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            frame = ref2[k];
            results1.push(frame.evaluate(function() {
              // window.frameElement.getAttribute("Name")
              return window.frameElement;
            }));
          }
          return results1;
        }).call(this);
        return Promise.all(promises).then(function(results) {
          return Promise.resolve();
        });
      }
    }

    popFrame(pop_all = false) {
      if (pop_all) {
        this.frames = [];
      } else {
        this.frames.pop();
      }
      return true;
    }

    dimensions() {
      return this.documentSize().then((d_size) => {
        var scroll, viewport;
        // scroll   = this.scrollPosition()
        scroll = {
          top: 0,
          left: 0
        };
        viewport = this.viewportSize();
        return {
          top: scroll.top,
          bottom: scroll.top + viewport.height,
          left: scroll.left,
          right: scroll.left + viewport.width,
          viewport: viewport,
          document: d_size
        };
      });
    }

    get(id) {
      return new Poltergeist.Node(this, id);
    }

    // Before each mouse event we make sure that the mouse is moved to where the
    // event will take place. This deals with e.g. :hover changes.
    mouseEvent(name, x, y, button = 'left') {
      switch (name) {
        case 'click':
          return this.native().mouse.click(x, y);
        case 'dblclick':
          return this.native().mouse.click(x, y, {
            clickCount: 2
          });
        case 'mousedown':
          // console.log "moving to #{x}, #{y} then downing mouse"
          return this.native().mouse.move(x, y).then(() => {
            return this.native().mouse.down;
          });
        case 'mouseup':
          // console.log "moving to #{x}, #{y} then uping mouse"
          return this.native().mouse.move(x, y).then(() => {
            return this.native().mouse.up;
          });
        default:
          throw `Unknown mouse event ${name}`;
      }
    }

    evaluate(fn, ...args) {
      var arg, fn_args, wrapped_fn;
      fn_args = (function() {
        var k, len2, ref2, results1;
        ref2 = [this.id, ...args];
        results1 = [];
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          arg = ref2[k];
          results1.push(JSON.stringify(arg));
        }
        return results1;
      }).call(this);
      wrapped_fn = `(function() { var page_id = arguments[0]; var args = []; for(var i=1; i < arguments.length; i++){ var arg = arguments[i]; if ((typeof(arg) == 'object') && (typeof(arg['ELEMENT']) == 'object')){ args.push(window.__poltergeist.get(arg['ELEMENT']['id']).element); } else { args.push(arg) } } var _result = ${this.stringifyCall(fn, "args")}; return window.__poltergeist.wrapResults(_result, page_id); })(${fn_args.join(',')})`;
      return this.currentFrame().evaluate(wrapped_fn).catch(function(err) {
        throw new Poltergeist.JavascriptError([
          {
            message: err.toString(),
            stack: err.toString()
          }
        ]);
      });
    }

    execute(fn, ...args) {
      var arg, fn_args, wrapped_fn;
      fn_args = (function() {
        var k, len2, results1;
        results1 = [];
        for (k = 0, len2 = args.length; k < len2; k++) {
          arg = args[k];
          results1.push(JSON.stringify(arg));
        }
        return results1;
      })();
      wrapped_fn = `(function() { var args = []; for(var i=0; i < arguments.length; i++){ var arg = arguments[i]; if ((typeof(arg) == 'object') && (typeof(arg['ELEMENT']) == 'object')){ args.push(window.__poltergeist.get(arg['ELEMENT']['id']).element); } else { args.push(arg) } } ${this.stringifyCall(fn, "args")} })(${fn_args.join(',')})`;
      return this.currentFrame().evaluate(wrapped_fn).catch(function(err) {
        throw new Poltergeist.JavascriptError([
          {
            message: err.toString(),
            stack: err.toString()
          }
        ]);
      });
    }

    stringifyCall(fn, args_name = "arguments") {
      return `(${fn.toString()}).apply(this, ${args_name})`;
    }

    bindCallback(name) {
      this.native().on(name, (...args) => {
        if (this[`on_${name}`] != null) {
          return this[`on_${name}`].apply(this, args);
        }
        return false;
      });
      return true;
    }

    // Any error raised here or inside the evaluate will get reported to
    // phantom.onError. If result is null, that means there was an error
    // inside the agent.
    runCommand(name, args) {
      return this.evaluate(function(cmd_name, cmd_args) {
        return __poltergeist.externalCall(cmd_name, cmd_args);
      }, name, args).then(function(result) {
        var method, selector;
        if ((result != null ? result.error : void 0) != null) {
          switch (result.error.message) {
            case 'PoltergeistAgent.ObsoleteNode':
              throw new Poltergeist.ObsoleteNode;
            case 'PoltergeistAgent.InvalidSelector':
              [method, selector] = args;
              throw new Poltergeist.InvalidSelector(method, selector);
            default:
              throw new Poltergeist.BrowserError(result.error.message, result.error.stack);
          }
        } else {
          return result != null ? result.value : void 0;
        }
      });
    }

    // canGoBack: ->
    //   this.native().canGoBack

    // canGoForward: ->
    //   this.native().canGoForward
    normalizeURL(url) {
      var parser;
      console.log("implement normalizeURL");
      parser = document.createElement('a');
      parser.href = url;
      return parser.href;
    }

    clearMemoryCache() {
      var clearMemoryCache;
      clearMemoryCache = this.native().clearMemoryCache;
      if (typeof clearMemoryCache === "function") {
        return clearMemoryCache();
      } else {
        throw new Poltergeist.UnsupportedFeature("clearMemoryCache is not supported in Puppeteer");
      }
    }

    async setBlacklist(bl) {
      this.urlBlacklist = bl;
      return (await this.native().setRequestInterceptionEnabled(this._intercepting));
    }

    async setWhitelist(bl) {
      this.urlWhitelist = bl;
      return (await this.native().setRequestInterceptionEnabled(this._intercepting));
    }

    _intercepting() {
      return this.urlWhitelist.length || this.urlBlacklist.length;
    }

    _blockRequest(url) {
      var blacklisted, useWhitelist, whitelisted;
      useWhitelist = this.urlWhitelist.length > 0;
      whitelisted = this.urlWhitelist.some(function(whitelisted_regex) {
        return whitelisted_regex.test(url);
      });
      blacklisted = this.urlBlacklist.some(function(blacklisted_regex) {
        return blacklisted_regex.test(url);
      });
      return (useWhitelist && !whitelisted) || blacklisted;
    }

    _add_injection(filePath) {
      return new Promise(function(resolve, reject) {
        var err;
        try {
          return fs.readFile(filePath, 'utf8', function(err, data) {
            if (err) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        } catch (error1) {
          err = error1;
          return reject(err);
        }
      }).then((contents) => {
        this.native().evaluateOnNewDocument(contents);
        return contents;
      });
    }

  };

  WebPage.CALLBACKS = ['onLoadFinished', 'onInitialized', 'onLoadStarted', 'onResourceReceived', 'onNavigationRequested', 'onUrlChanged', 'onPageCreated', 'onClosing', 'request', 'requestfinished', 'requestfailed', 'response', 'error', 'pageerror', 'console', 'framenavigated', 'frameattached', 'load'];

  WebPage.PAGE_DELEGATES = ['goto', 'render', 'close', 'goBack', 'goForward', 'reload'];

  WebPage.COMMANDS = ['find', 'nodeCall', 'documentSize', 'beforeAction', 'afterAction', 'clearLocalStorage'];

  WebPage.EXTENSIONS = [];

  ref = WebPage.COMMANDS;
  fn1 = (command) => {
    return WebPage.prototype[command] = function(...args) {
      return this.runCommand(command, args);
    };
  };
  for (i = 0, len = ref.length; i < len; i++) {
    command = ref[i];
    fn1(command);
  }

  ref1 = WebPage.PAGE_DELEGATES;
  fn2 = (delegate) => {
    return WebPage.prototype[delegate] = function() {
      var ref2;
      return (ref2 = this._native[delegate]) != null ? ref2.apply(this._native, arguments) : void 0;
    };
  };
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    delegate = ref1[j];
    fn2(delegate);
  }

  return WebPage;

})();
